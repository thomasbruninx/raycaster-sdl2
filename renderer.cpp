#include "renderer.h"

#include <algorithm>
#include <array>
#include <cmath>
#include <cstdint>
#include <sstream>
#include <string>

#include "doors.h"
#include "textures.h"

namespace {
// 8x8 bitmap font (font8x8_basic)
static const uint8_t FONT[128][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x00
    {0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e}, // 0x01
    {0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e}, // 0x02
    {0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00}, // 0x03
    {0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00}, // 0x04
    {0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x92, 0x10, 0x7c}, // 0x05
    {0x00, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x10, 0x38}, // 0x06
    {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00}, // 0x07
    {0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff}, // 0x08
    {0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00}, // 0x09
    {0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff}, // 0x0a
    {0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78}, // 0x0b
    {0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18}, // 0x0c
    {0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0}, // 0x0d
    {0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0}, // 0x0e
    {0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99}, // 0x0f
    {0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00}, // 0x10
    {0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00}, // 0x11
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18}, // 0x12
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00}, // 0x13
    {0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00}, // 0x14
    {0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78}, // 0x15
    {0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00}, // 0x16
    {0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff}, // 0x17
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00}, // 0x18
    {0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00}, // 0x19
    {0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00}, // 0x1a
    {0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00}, // 0x1b
    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00}, // 0x1c
    {0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00}, // 0x1d
    {0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00}, // 0x1e
    {0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00}, // 0x1f
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x20 (space)
    {0x18, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x00}, // 0x21 (!)
    {0x36, 0x36, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x22 (")
    {0x36, 0x36, 0x7f, 0x36, 0x7f, 0x36, 0x36, 0x00}, // 0x23 (#)
    {0x0c, 0x3e, 0x03, 0x1e, 0x30, 0x1f, 0x0c, 0x00}, // 0x24 ($)
    {0x00, 0x63, 0x33, 0x18, 0x0c, 0x66, 0x63, 0x00}, // 0x25 (%)
    {0x1c, 0x36, 0x1c, 0x6e, 0x3b, 0x33, 0x6e, 0x00}, // 0x26 (&)
    {0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x27 (')
    {0x18, 0x0c, 0x06, 0x06, 0x06, 0x0c, 0x18, 0x00}, // 0x28 (()
    {0x06, 0x0c, 0x18, 0x18, 0x18, 0x0c, 0x06, 0x00}, // 0x29 ())
    {0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00}, // 0x2a (*)
    {0x00, 0x0c, 0x0c, 0x3f, 0x0c, 0x0c, 0x00, 0x00}, // 0x2b (+)
    {0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x06, 0x00}, // 0x2c (,)
    {0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00}, // 0x2d (-)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00}, // 0x2e (.)
    {0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x01, 0x00}, // 0x2f (/)
    {0x3e, 0x63, 0x73, 0x7b, 0x6f, 0x67, 0x3e, 0x00}, // 0x30 (0)
    {0x0c, 0x0e, 0x0c, 0x0c, 0x0c, 0x0c, 0x3f, 0x00}, // 0x31 (1)
    {0x1e, 0x33, 0x30, 0x1c, 0x06, 0x33, 0x3f, 0x00}, // 0x32 (2)
    {0x1e, 0x33, 0x30, 0x1c, 0x30, 0x33, 0x1e, 0x00}, // 0x33 (3)
    {0x38, 0x3c, 0x36, 0x33, 0x7f, 0x30, 0x78, 0x00}, // 0x34 (4)
    {0x3f, 0x03, 0x1f, 0x30, 0x30, 0x33, 0x1e, 0x00}, // 0x35 (5)
    {0x1c, 0x06, 0x03, 0x1f, 0x33, 0x33, 0x1e, 0x00}, // 0x36 (6)
    {0x3f, 0x33, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x00}, // 0x37 (7)
    {0x1e, 0x33, 0x33, 0x1e, 0x33, 0x33, 0x1e, 0x00}, // 0x38 (8)
    {0x1e, 0x33, 0x33, 0x3e, 0x30, 0x18, 0x0e, 0x00}, // 0x39 (9)
    {0x00, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x0c, 0x00}, // 0x3a (:)
    {0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x0c, 0x06, 0x00}, // 0x3b (;)
    {0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x00}, // 0x3c (<)
    {0x00, 0x00, 0x3f, 0x00, 0x3f, 0x00, 0x00, 0x00}, // 0x3d (=)
    {0x06, 0x0c, 0x18, 0x30, 0x18, 0x0c, 0x06, 0x00}, // 0x3e (>)
    {0x1e, 0x33, 0x30, 0x18, 0x0c, 0x00, 0x0c, 0x00}, // 0x3f (?)
    {0x3e, 0x63, 0x7b, 0x7b, 0x7b, 0x03, 0x1e, 0x00}, // 0x40 (@)
    {0x0c, 0x1e, 0x33, 0x33, 0x3f, 0x33, 0x33, 0x00}, // 0x41 (A)
    {0x3f, 0x66, 0x66, 0x3e, 0x66, 0x66, 0x3f, 0x00}, // 0x42 (B)
    {0x3c, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3c, 0x00}, // 0x43 (C)
    {0x1f, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1f, 0x00}, // 0x44 (D)
    {0x7f, 0x46, 0x16, 0x1e, 0x16, 0x46, 0x7f, 0x00}, // 0x45 (E)
    {0x7f, 0x46, 0x16, 0x1e, 0x16, 0x06, 0x0f, 0x00}, // 0x46 (F)
    {0x3c, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7c, 0x00}, // 0x47 (G)
    {0x33, 0x33, 0x33, 0x3f, 0x33, 0x33, 0x33, 0x00}, // 0x48 (H)
    {0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x1e, 0x00}, // 0x49 (I)
    {0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1e, 0x00}, // 0x4a (J)
    {0x67, 0x66, 0x36, 0x1e, 0x36, 0x66, 0x67, 0x00}, // 0x4b (K)
    {0x0f, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7f, 0x00}, // 0x4c (L)
    {0x63, 0x77, 0x7f, 0x7f, 0x6b, 0x63, 0x63, 0x00}, // 0x4d (M)
    {0x63, 0x67, 0x6f, 0x7b, 0x73, 0x63, 0x63, 0x00}, // 0x4e (N)
    {0x1c, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1c, 0x00}, // 0x4f (O)
    {0x3f, 0x66, 0x66, 0x3f, 0x06, 0x06, 0x0f, 0x00}, // 0x50 (P)
    {0x1e, 0x33, 0x33, 0x33, 0x3b, 0x1e, 0x38, 0x00}, // 0x51 (Q)
    {0x3f, 0x66, 0x66, 0x3f, 0x36, 0x66, 0x67, 0x00}, // 0x52 (R)
    {0x1e, 0x33, 0x07, 0x0e, 0x38, 0x33, 0x1e, 0x00}, // 0x53 (S)
    {0x3f, 0x2d, 0x0c, 0x0c, 0x0c, 0x0c, 0x1e, 0x00}, // 0x54 (T)
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3f, 0x00}, // 0x55 (U)
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x1e, 0x0c, 0x00}, // 0x56 (V)
    {0x63, 0x63, 0x63, 0x6b, 0x7f, 0x77, 0x63, 0x00}, // 0x57 (W)
    {0x63, 0x63, 0x36, 0x1c, 0x1c, 0x36, 0x63, 0x00}, // 0x58 (X)
    {0x33, 0x33, 0x33, 0x1e, 0x0c, 0x0c, 0x1e, 0x00}, // 0x59 (Y)
    {0x7f, 0x63, 0x31, 0x18, 0x4c, 0x66, 0x7f, 0x00}, // 0x5a (Z)
    {0x1e, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1e, 0x00}, // 0x5b ([)
    {0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x00}, // 0x5c (\)
    {0x1e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1e, 0x00}, // 0x5d (])
    {0x08, 0x1c, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00}, // 0x5e (^)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff}, // 0x5f (_)
    {0x0c, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x60 (`)
    {0x00, 0x00, 0x1e, 0x30, 0x3e, 0x33, 0x6e, 0x00}, // 0x61 (a)
    {0x07, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x3b, 0x00}, // 0x62 (b)
    {0x00, 0x00, 0x1e, 0x33, 0x03, 0x33, 0x1e, 0x00}, // 0x63 (c)
    {0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6e, 0x00}, // 0x64 (d)
    {0x00, 0x00, 0x1e, 0x33, 0x3f, 0x03, 0x1e, 0x00}, // 0x65 (e)
    {0x1c, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0f, 0x00}, // 0x66 (f)
    {0x00, 0x00, 0x6e, 0x33, 0x33, 0x3e, 0x30, 0x1f}, // 0x67 (g)
    {0x07, 0x06, 0x36, 0x6e, 0x66, 0x66, 0x67, 0x00}, // 0x68 (h)
    {0x0c, 0x00, 0x0e, 0x0c, 0x0c, 0x0c, 0x1e, 0x00}, // 0x69 (i)
    {0x30, 0x00, 0x38, 0x30, 0x30, 0x33, 0x33, 0x1e}, // 0x6a (j)
    {0x07, 0x06, 0x66, 0x36, 0x1e, 0x36, 0x67, 0x00}, // 0x6b (k)
    {0x0e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x1e, 0x00}, // 0x6c (l)
    {0x00, 0x00, 0x33, 0x7f, 0x7f, 0x6b, 0x63, 0x00}, // 0x6d (m)
    {0x00, 0x00, 0x1f, 0x33, 0x33, 0x33, 0x33, 0x00}, // 0x6e (n)
    {0x00, 0x00, 0x1e, 0x33, 0x33, 0x33, 0x1e, 0x00}, // 0x6f (o)
    {0x00, 0x00, 0x3b, 0x66, 0x66, 0x3e, 0x06, 0x0f}, // 0x70 (p)
    {0x00, 0x00, 0x6e, 0x33, 0x33, 0x3e, 0x30, 0x78}, // 0x71 (q)
    {0x00, 0x00, 0x3b, 0x6e, 0x66, 0x06, 0x0f, 0x00}, // 0x72 (r)
    {0x00, 0x00, 0x3e, 0x03, 0x1e, 0x30, 0x1f, 0x00}, // 0x73 (s)
    {0x08, 0x0c, 0x3e, 0x0c, 0x0c, 0x2c, 0x18, 0x00}, // 0x74 (t)
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6e, 0x00}, // 0x75 (u)
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x1e, 0x0c, 0x00}, // 0x76 (v)
    {0x00, 0x00, 0x63, 0x6b, 0x7f, 0x7f, 0x36, 0x00}, // 0x77 (w)
    {0x00, 0x00, 0x63, 0x36, 0x1c, 0x36, 0x63, 0x00}, // 0x78 (x)
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x3e, 0x30, 0x1f}, // 0x79 (y)
    {0x00, 0x00, 0x3f, 0x19, 0x0c, 0x26, 0x3f, 0x00}, // 0x7a (z)
    {0x38, 0x0c, 0x0c, 0x07, 0x0c, 0x0c, 0x38, 0x00}, // 0x7b ({)
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00}, // 0x7c (|)
    {0x07, 0x0c, 0x0c, 0x38, 0x0c, 0x0c, 0x07, 0x00}, // 0x7d (})
    {0x6e, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 0x7e (~)
    {0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00}, // 0x7f
};

Color wallColor(int id, bool isSideHit) {
    static const std::array<Color, 6> palette = {{
        {0, 0, 0},       // unused
        {200, 60, 60},   // red
        {60, 160, 200},  // blue
        {60, 200, 120},  // green
        {220, 200, 80},  // yellow
        {160, 160, 180}, // door color fallback
    }};
    Color c = palette[std::min(id, static_cast<int>(palette.size() - 1))];
    if (isSideHit) {
        c.r = static_cast<Uint8>(c.r * 0.7);
        c.g = static_cast<Uint8>(c.g * 0.7);
        c.b = static_cast<Uint8>(c.b * 0.7);
    }
    return c;
}

Color doorRenderColor(const Door& door, bool isSideHit) {
    Color base{150, 170, 190};
    double visibility = 1.0 - door.openAmount * 0.7; // fade as it opens
    base.r = static_cast<Uint8>(base.r * visibility);
    base.g = static_cast<Uint8>(base.g * visibility);
    base.b = static_cast<Uint8>(base.b * visibility);
    if (isSideHit) {
        base.r = static_cast<Uint8>(base.r * 0.8);
        base.g = static_cast<Uint8>(base.g * 0.8);
        base.b = static_cast<Uint8>(base.b * 0.8);
    }
    return base;
}

void drawChar(SDL_Renderer* renderer, int x, int y, char ch, int scale, Color color) {
    unsigned char idx = static_cast<unsigned char>(ch);
    const uint8_t* bitmap = FONT[idx];
    SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, 255);
    for (int row = 0; row < 8; ++row) {
        uint8_t bits = bitmap[row];
        for (int col = 0; col < 8; ++col) {
            if (bits & (1u << col)) {
                SDL_Rect r{x + col * scale, y + row * scale, scale, scale};
                SDL_RenderFillRect(renderer, &r);
            }
        }
    }
}

int drawText(SDL_Renderer* renderer, int x, int y, const std::string& text, int scale, Color color) {
    int cursor = x;
    for (char ch : text) {
        drawChar(renderer, cursor, y, ch, scale, color);
        cursor += 8 * scale + scale;
    }
    return cursor;
}

void drawConsoleOverlay(const Config& cfg, SDL_Renderer* renderer, const ConsoleState& console) {
    int consoleHeight = static_cast<int>(cfg.screenHeight * 0.35);
    SDL_Rect bg{0, cfg.screenHeight - consoleHeight, cfg.screenWidth, consoleHeight};
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 170);
    SDL_RenderFillRect(renderer, &bg);
    SDL_SetRenderDrawColor(renderer, 80, 80, 80, 220);
    SDL_RenderDrawRect(renderer, &bg);

    int padding = 8;
    int scale = 2;
    int lineHeight = 8 * scale + 4;
    int inputY = cfg.screenHeight - padding - lineHeight;
    int logAreaHeight = inputY - (cfg.screenHeight - consoleHeight + padding);
    int maxLogLines = std::max(0, logAreaHeight / lineHeight);
    int start = static_cast<int>(console.log.size()) - maxLogLines;
    if (start < 0) {
        start = 0;
    }
    int y = inputY - lineHeight * std::min(maxLogLines, static_cast<int>(console.log.size()));
    Color textColor{200, 200, 200};
    for (size_t i = start; i < console.log.size(); ++i) {
        drawText(renderer, padding, y, console.log[i], scale, textColor);
        y += lineHeight;
    }

    std::string prompt = "> " + console.input;
    int cursorX = drawText(renderer, padding, inputY, prompt, scale, {240, 240, 240});
    SDL_SetRenderDrawColor(renderer, 240, 240, 240, 255);
    SDL_Rect cursor{cursorX, inputY, scale * 2, 8 * scale};
    SDL_RenderFillRect(renderer, &cursor);
}

void drawMinimap(const Map& map, const Player& player, SDL_Renderer* renderer, int size, int margin) {
    int x0 = margin;
    int y0 = margin;
    SDL_Rect bg{x0, y0, size, size};
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 160);
    SDL_RenderFillRect(renderer, &bg);
    SDL_SetRenderDrawColor(renderer, 70, 70, 70, 200);
    SDL_RenderDrawRect(renderer, &bg);
    SDL_RenderSetClipRect(renderer, &bg);

    double angle = std::atan2(player.dirY, player.dirX);
    const double halfPi = 1.5707963267948966;
    double rot = -angle - halfPi; // Player faces "up" on the minimap.
    double cosA = std::cos(rot);
    double sinA = std::sin(rot);
    double scale = 6.0;
    double cx = x0 + size / 2.0;
    double cy = y0 + size / 2.0;

    auto worldToMini = [&](double wx, double wy, int& outX, int& outY) {
        double dx = wx - player.x;
        double dy = wy - player.y;
        double rx = dx * cosA - dy * sinA;
        double ry = dx * sinA + dy * cosA;
        rx = -rx; // mirror projection horizontally
        outX = static_cast<int>(cx + rx * scale);
        outY = static_cast<int>(cy + ry * scale);
    };

    auto drawTile = [&](int cellX, int cellY, SDL_Color color) {
        int tlx, tly, trx, try_, brx, bry, blx, bly;
        worldToMini(cellX, cellY, tlx, tly);
        worldToMini(cellX + 1, cellY, trx, try_);
        worldToMini(cellX + 1, cellY + 1, brx, bry);
        worldToMini(cellX, cellY + 1, blx, bly);
        SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, 255);
        SDL_RenderDrawLine(renderer, tlx, tly, trx, try_);
        SDL_RenderDrawLine(renderer, trx, try_, brx, bry);
        SDL_RenderDrawLine(renderer, brx, bry, blx, bly);
        SDL_RenderDrawLine(renderer, blx, bly, tlx, tly);
    };

    for (int y = 0; y < map.height; ++y) {
        for (int x = 0; x < map.width; ++x) {
            int tile = map.tiles[y * map.width + x];
            if (tile == 0) continue;
            SDL_Color color = (tile == DOOR_TILE) ? SDL_Color{230, 200, 40, 255} : SDL_Color{240, 240, 240, 255};
            drawTile(x, y, color);
        }
    }

    int px, py;
    worldToMini(player.x, player.y, px, py);
    SDL_SetRenderDrawColor(renderer, 60, 220, 110, 255);
    SDL_Rect playerDot{px - 2, py - 2, 4, 4};
    SDL_RenderFillRect(renderer, &playerDot);

    SDL_RenderSetClipRect(renderer, nullptr);
}
} // namespace

void renderFrame(const Map& map, const std::vector<Door>& doors, const Player& player, const Config& cfg, SDL_Renderer* renderer, const TextureManager& tm, const ConsoleState& console, bool showMinimap, double fps) {
    SDL_SetRenderDrawColor(renderer, 30, 30, 30, 255);
    SDL_RenderClear(renderer);

    SDL_Rect skyRect{0, 0, cfg.screenWidth, cfg.screenHeight / 2};
    SDL_SetRenderDrawColor(renderer, 60, 60, 90, 255);
    SDL_RenderFillRect(renderer, &skyRect);

    // Floor gradient
    for (int y = cfg.screenHeight / 2; y < cfg.screenHeight; ++y) {
        Uint8 shade = static_cast<Uint8>(40 + 80.0 * (y - cfg.screenHeight / 2) / (cfg.screenHeight / 2));
        SDL_SetRenderDrawColor(renderer, shade, shade, shade, 255);
        SDL_RenderDrawLine(renderer, 0, y, cfg.screenWidth, y);
    }

    for (int x = 0; x < cfg.screenWidth; ++x) {
        double cameraX = 2.0 * x / cfg.screenWidth - 1.0;
        double rayDirX = player.dirX + player.planeX * cameraX;
        double rayDirY = player.dirY + player.planeY * cameraX;

        int mapX = static_cast<int>(player.x);
        int mapY = static_cast<int>(player.y);

        double deltaDistX = (rayDirX == 0) ? 1e30 : std::abs(1.0 / rayDirX);
        double deltaDistY = (rayDirY == 0) ? 1e30 : std::abs(1.0 / rayDirY);

        double sideDistX;
        double sideDistY;
        int stepX;
        int stepY;

        if (rayDirX < 0) {
            stepX = -1;
            sideDistX = (player.x - mapX) * deltaDistX;
        } else {
            stepX = 1;
            sideDistX = (mapX + 1.0 - player.x) * deltaDistX;
        }

        if (rayDirY < 0) {
            stepY = -1;
            sideDistY = (player.y - mapY) * deltaDistY;
        } else {
            stepY = 1;
            sideDistY = (mapY + 1.0 - player.y) * deltaDistY;
        }

        bool hit = false;
        bool side = false;
        int wallId = 0;
        double doorHitDist = -1.0;
        const Door* hitDoor = nullptr;
        while (!hit) {
            if (sideDistX < sideDistY) {
                sideDistX += deltaDistX;
                mapX += stepX;
                side = false;
            } else {
                sideDistY += deltaDistY;
                mapY += stepY;
                side = true;
            }

            int tile = map.at(mapX, mapY);
            if (tile == DOOR_TILE) {
                const Door* door = findDoor(doors, mapX, mapY);
                if (door && door->openAmount < 0.99) {
                    double dist;
                    bool doorSide;
                    if (computeDoorHit(*door, player, rayDirX, rayDirY, dist, doorSide)) {
                        hit = true;
                        wallId = DOOR_TILE;
                        doorHitDist = dist;
                        side = doorSide;
                        hitDoor = door;
                    }
                }
                if (!hit) {
                    continue; // fully open or no intersection; keep marching
                }
            }

            if (tile > 0 && tile != DOOR_TILE) {
                hit = true;
                wallId = tile;
            }
        }

        double perpWallDist = (doorHitDist > 0.0) ? doorHitDist
                                                 : (side ? (sideDistY - deltaDistY) : (sideDistX - deltaDistX));
        if (perpWallDist <= 0.0001) {
            perpWallDist = 0.0001;
        }
        int lineHeight = static_cast<int>(cfg.wallHeight * cfg.screenHeight / perpWallDist);
        int drawStart = -lineHeight / 2 + cfg.screenHeight / 2;
        int drawEnd = lineHeight / 2 + cfg.screenHeight / 2;

        double hitX = player.x + perpWallDist * rayDirX;
        double hitY = player.y + perpWallDist * rayDirY;
        double wallX;
        if (hitDoor) {
            if (hitDoor->vertical) {
                double offsetY = hitDoor->y + hitDoor->openAmount;
                wallX = hitY - offsetY;
            } else {
                double offsetX = hitDoor->x + hitDoor->openAmount;
                wallX = hitX - offsetX;
            }
            wallX -= std::floor(wallX);
        } else {
            wallX = side ? hitX : hitY;
            wallX -= std::floor(wallX);
        }

        SDL_Surface* surf = nullptr;
        if (wallId >= 0 && wallId < static_cast<int>(tm.textures.size())) {
            surf = tm.textures[wallId];
        }
        int texW = surf ? surf->w : 1;
        int texH = surf ? surf->h : 1;
        int texX = static_cast<int>(wallX * texW);
        if (!side && rayDirX > 0) {
            texX = texW - texX - 1;
        }
        if (side && rayDirY < 0) {
            texX = texW - texX - 1;
        }
        // Mirror door texture when viewed from the back side.
        bool mirrorDoor = hitDoor && (hitDoor->vertical ? (rayDirX > 0) : (rayDirY > 0));
        if (mirrorDoor) {
            texX = texW - texX - 1;
        }

        double texStep = static_cast<double>(texH) / lineHeight;
        double texPos = (drawStart - cfg.screenHeight / 2 + lineHeight / 2) * texStep;

        for (int y = drawStart; y <= drawEnd; ++y) {
            if (y < 0 || y >= cfg.screenHeight) {
                texPos += texStep;
                continue;
            }
            int texY = static_cast<int>(texPos) & (texH - 1);
            texPos += texStep;
            Color c = surf ? sampleTexture(surf, texX, texY)
                           : (hitDoor ? doorRenderColor(*hitDoor, side) : wallColor(wallId, side));
            if (side) {
                c.r = static_cast<Uint8>(c.r * 0.7);
                c.g = static_cast<Uint8>(c.g * 0.7);
                c.b = static_cast<Uint8>(c.b * 0.7);
            }
            SDL_SetRenderDrawColor(renderer, c.r, c.g, c.b, 255);
            SDL_RenderDrawPoint(renderer, x, y);
        }
    }

    if (showMinimap) {
        drawMinimap(map, player, renderer, 250, 8);
    }

    if (console.showFPS) {
        std::ostringstream oss;
        oss.precision(1);
        oss << std::fixed << fps << " fps";
        std::string text = oss.str();
        int scale = 2;
        int charWidth = 8 * scale + scale;
        int textWidth = static_cast<int>(text.size()) * charWidth;
        int x = cfg.screenWidth - textWidth - 8;
        int y = 8;
        drawText(renderer, x, y, text, scale, {240, 240, 240});
    }

    if (console.open) {
        drawConsoleOverlay(cfg, renderer, console);
    }

    SDL_RenderPresent(renderer);
}
